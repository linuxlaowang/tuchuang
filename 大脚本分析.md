# global_func.sh 全局函数
1.
```shell
set -o nounset                              # Treat unset variables as an error
```
2.  动态定位当前终端设备的目录。适用于需要动态感知终端环境的脚本场景。核心逻辑是：找 stdin → 取路径 → 切目录
```
cd $(dirname `/usr/sbin/lsof -p $$ | gawk '$4 == "255r" {print $NF}'`)
```
语法解释，用于理解后续脚本内容  
#当终端通过 SSH、本地 tty 或 pts 设备连接时，此命令可快速进入终端设备所在的系统目录（如/dev/pts），
* $$    当前 Shell 进程的 PID（进程 ID），例如12345。
* /usr/sbin/lsof -p $$    列出当前进程打开的所有文件（lsof：list open files）。截取$4 是255r的文件路径。
* 255r：表示标准输入（stdin）的文件描述符（Linux 中 255 是 bash 默认的 stdin FD）。

# upload_batch.sh
1. 定义了一个别名，用于检查上一个命令的返回值，若不为 0 则返回 1
```
set -o nounset                              # Treat unset variables as an error  
shopt -s expand_aliases                                       #expand_aliases on
alias CHECKRETURN='[[ "$?" != "0" ]] && return 1'   ##定义了一个别名，用于检查上一个命令的返回值，若不为 0 则返回 1
alias CHECKRETURN_N='log_check "test $1 network ..." ${LOG_DEBUG} || return 1'               #定义了另外两个别名，借助 log_check 函数进行日志检查，若检查失败则返回 1
alias CHECKRETURN_D='log_check "running $1 pwd ..." ${LOG_DEBUG} || return 1'
```
2. 等价于 source 命令，但 . 更简洁（尤其在脚本中）。即：执行当前脚本中的函数。
```
. ./global_func.sh && . ./global_vars.sh  
```

3. 传参
```
## 参数
only_ip=""
host_file=""
task_script=""
shell_run=""
ssh_client=""

# 参数解析
while getopts h:i:t:s:p:plr opt; do
     case "$opt" in
         i) only_ip=$OPTARG;;
         h) host_file=$OPTARG ;;
         t) task_script=$OPTARG ;;
         s) shell_run=$OPTARG ;;
         p) ssh_client=$OPTARG ;;
         *) f_print_help; exit 1 ;;
     esac
done
```
# 关于数据盘初始化的脚本理解
1.
```
#当bash storage_isolation_op.sh  的过程中，会使用参数: ARG_PARTITION="yes"
#当bash storage_isolation_op.sh -r 的过程中，会传入参数：     ARG_PARTITION="no"
在bash这个脚本的过程中，会有如下判断过程：
if [[ ${ARG_PARTITION} == "yes" ]]; then
        isolation ${device} ${type} ${mkfs}                    
#若是为yes，则会使用 存储隔离的方式，创建lv进行挂载的过程。默认为40:40:40:40 进程lv的创建。
    else
        recovery ${device} ${type} ${mkfs}                     
#若是为no，则只是执行recovery的过程。该函数只是做了mount -a 重新进行了挂载，对于清理磁盘以及其他步骤均是其他前置步骤完成的：即：卸载/data，删除vg-data，vg-vm等。then：格式化/dev/nvme0n1p4，并且 直接挂载到 /data 目录，没有lv这个过程。
    fi
```
```shell
unction is_data_varfs() {
    local line=$(grep "/var/log" /etc/fstab | grep /data/varfs | grep -v -E "^[ \t]*#")
#此代码的用途是从 /etc/fstab 文件里筛选出同时包含 /var/log 和 /data/varfs，并且不以 # 开头的行。
#[ \t]*：[ \t] 表示匹配空格或制表符，* 表示前面的字符（空格或制表符）可以出现零次或多次。
#在 [ \t] 这个字符类里，空格和制表符都被包含在内。这意味着当正则表达式引擎遇到这个字符类时，它会尝试匹配空格或者制表符这两种字符中的任意一个。要是不使用方括号，就只能匹配单一的字符。例如，只写 （一个空格）就只能匹配空格，而不能匹配制表符；只写 \t 就只能匹配制表符，不能匹配空格。
#即：中括号的作用是：用于匹配多种字符。
    if [[ -n ${line} ]]; then
        echo ${COMMON_RESULT_YES}
    else
        echo ${COMMON_RESULT_NO}
    fi
}
```
3. 通过读取系统固件设备树中的 compatible 文件内容，依据文件内容里的关键字来判断 SoC 的类型，若无法识别则返回未知类型。
```
 local DTS_FILE="/sys/firmware/devicetree/base/compatible"
```
4. 常见bug
```
 while mount | grep -q /data; do
        losetup -D
        swapoff -a
        #fuser -vmk /data
##这条会把ssh连接kill掉 更换成重启,若是有ssh进程使用到了data目录。
```
5. `tr -d '\0' </etc/fstab`  读取 /etc/fstab 文件的内容，并删除其中的所有空字符，然后将处理后的内容输出到标准输出.\0 代表空字符（null character），其 ASCII 码值为 0，是计算机中表示 “没有字符” 的特殊符号，通常用于 C 语言字符串结尾或二进制文件中的分隔符。
6. authorized_keys 文件则用于存放允许通过 SSH 登录到该系统的公钥，每个公钥占一行。
7. SSH 服务要求：SSH 服务在进行公钥认证时，会检查 authorized_keys 文件的权限。如果文件权限设置不当，SSH 服务可能会拒绝使用该文件进行认证，以防止潜在的安全风险。因此，为了确保 SSH 公钥认证能够正常工作，通常需要将 authorized_keys 文件的权限设置为 600。
8. `${#array[@]}` 表示数组 array 的元素个数
9. ` IFS=":"    array=(${ARG_VM_DATA_SIZE_LIST})` #ARG_VM_DATA_SIZE_LIST="40:40:40:40"  默认为这个，也可以通过-s 进行传参。#表示 array=(40 40 40 40)  #由于 IFS 已经被设置为 :，Bash 在解析 ARG_VM_DATA_SIZE_LIST 这个字符串时，会以 : 作为分隔符将其分割成多个部分，然后把这些部分存储到数组 array 中。最终，array 数组的值就变成了 (40 40 40 40)。
10. `IFS="$OLD_IFS"`  ##在完成字符串分割操作之后，将 IFS 的值恢复为原始值，这样后续的命令就会继续使用默认的分隔符（空格、制表符和换行符）进行单词分割。
11. `exec >>${LOG_FILE} 2>&1 ` exec 用于在当前 shell 进程中执行指定的命令，并且会替换当前 shell 进程。不会显示具体执行的过程，而是显示返回的内容。
12. `eval mkfs.ext4 -F /dev/nvme0n1p4` 它的作用是将其后面的参数作为一个完整的命令进行解析和执行。也就是说，eval 会把传递给它的字符串当作一个 shell 命令来处理，然后执行该命令。
13. `sed -i "$(( $(wc -l < /etc/fstab) - 1 )),$ s/^/#/" /etc/fstab`  
#wc -l < /etc/fstab：计算 /etc/fstab 的总行数（wc -l 统计行数）。 相当于 cat /etc/fstab | wc -l
#$(( ... - 1 ))：用算术扩展计算 “总行数 - 1”，即 “倒数第二行” 的行号。
即：`sed -i "3,$"`  #表示： 3到最后一行，这个意思是： 从倒数第二行到最后一行

# dufs脚本
1. 过滤apt已经下载的包 `apt list --installed  2>/dev/null | grep -e nginx-full/ -e libtar0/`
2. 手动执行：`/bin/bash /data/local/device_update/tmp/output/acb-dufs/update.sh`    
#set -e 会在执行报错时，会自动跳出该脚本。所以后续排查不能拘于表象。
#可能报错：check：`systemctl enable fcgiwrap  #这一步报错了` 或者 `/etc/init.d 下查看对应的fcgiwrap，是否有对应的内容。`
# 盛和高配刷机之前报错提前跑此函数
```
function shenghe_gaopei_remove_f2fs()
{
    ssh_fun $1 "cp /etc/fstab /etc/fstab.bak"
    ssh_fun $1 "if [ -f /etc/fstab.bak ];then echo 'PARTLABEL=rootfs /     ext4   rw,relatime,data=ordered 0 1' > /etc/fstab;fi && echo '/data/varfs       /var/log   none   defaults,bind           0 0' >> /etc/fstab"
    CHECKRETURN

}
```
   