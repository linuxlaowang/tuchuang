1、看下toc离线因子脚本。

42.115服务器：/data/device/tuqi/FlashMachine/845_10/init/ 目录下的  check_device_down_toc() 函数。有时间可以看下
/data/device/tuqi/FlashMachine/845_10/init/file/check_device_down_toc.sh  #这个toc离线分析脚本

# 日常记忆
1. netcat  ：apt-get -y install netcat     即：nc检测tcp与udp的方法
   *        nc -zv 10.6.226.211 7918  
   *        nc -zvu 10.6.226.211 7918

2. 列出systemctl 所加载的所有服务
   * systemctl list-units --type=service
3.  /data/system/users/0 # rm -vf wall*           
     am restart

4. cat tongji.log|egrep '[0-9] $'|wc -l
5. sh upload_batch.sh -h only_ip.txt -s 'md5sum /data/lxc_volumns/root_?/init.rc|paste -sd ,'|tee tongji.log
cat tongji.log|grep -P "^1" |awk '{$1="";print}'|sort |uniq -c|sort

6. cat only_ip.txt |cut -d . -f 1-3|sort -u

7. 学习：详细解释下正则表达式中的零宽断言：匹配字符位置
解释：正则表达式中的 零宽断言（Zero-width Assertion） 是一种特殊的匹配结构，它不匹配任何实际字符，只匹配字符串中的某个位置（类似光标位置），且该位置需满足特定条件。由于不消耗字符（“零宽”），仅用于定位，因此常被用来精准匹配 “某个内容之前 / 之后” 的文本。
根据位置的条件（前 / 后）和匹配逻辑（肯定 / 否定），零宽断言分为 4 种：
(?=pattern)            匹配一个位置，该位置后面的内容能匹配 pattern                       站在当前位置（即：？），往后看是否符合条件；      肯定前瞻:匹配 “后面是某内容” 的位置
(?!pattern)            匹配一个位置，该位置后面的内容不能匹配 pattern                     站在当前位置，往后看是否符合条件；       否定前瞻:匹配 “后面不是某内容” 的位置   
(?<=pattern)           匹配一个位置，该位置前面的内容能匹配 pattern                       站在当前位置，往前看是否符合条件；          肯定后顾:匹配 “前面是某内容” 的位置
(?<!pattern)           匹配一个位置，该位置前面的内容不能匹配 pattern                     站在当前位置，往前看是否符合条件；          否定后顾:匹配 “前面不是某内容” 的位置

举例1：
需求：从字符串 I have 100 apples and 200 bananas 中，匹配 “后面跟 apples” 的数字。
\d+(?= apples)
                               解释：后面是指例如：200  后面跟着apples 的数字， 那就是100 apples 中的100.即：从数字往后看
需求：从上面的字符串中，匹配 “后面不是apples” 的数字。
\d+(?! apples)

需求：从字符串 price: $99, discount: ¥50 中，匹配 “前面是 $” 的数字。
(?<=\$)\d+


需求：从上面的字符串中，匹配 “前面不是$” 的数字。
(?<!\$)\d+

提示：零宽：不匹配实际字符，只定位位置，因此匹配结果中不会包含断言的内容（例如 (?<=\$)\d+ 只返回 99，不包含 $）；
复杂格式验证（如密码必须包含字母和数字：^(?=.*[A-Za-z])(?=.*\d).+$）
解释：  
         ^$ 已经锚定好开头结尾
         \d：匹配任意一个数字（0-9）。
         .+：匹配字符串主体：.：匹配任意单个字符（除换行符外）；+：表示 “至少匹配 1 次”。
         (?=.*[A-Za-z])      符合：肯定前瞻断言。表示站在当前位置，后面是.*[A-Za-z]    ，即： a123、123a、1a23 都符合要求。 
                                           .* 表示 “任意字符（除换行外）重复任意次”（可以是 0 次，即 “什么都没有”）；
                                           .+ 表示匹配任意单个字符“至少匹配 1 次”（除换行符外） 
8. 精确ip地址的获取
有效ip地址为 0.0.0.0-255.255.255.255  
思路：  
1. 我们要获取到：`250-255 200-249 0-200`
```
25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?
```
2. 我们要获取到：x.x.x.x 后面无点，前面有点.我们先表示 x.x.x
```
((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
```
3. 我们要获取到最后一位
```
((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[0-9]?[0-9][0-9]?)

##########
25[0-5] 负责 250-255
2[0-4][0-9] 负责 200-249
[01]?[0-9][0-9]? 负责 000-199
三者加起来正好是 0-255，完美覆盖了 IPv4 单段数字的合法范围～

```
综上，最后结果为  `((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)`  
但 [0-9.]+ 胜在简单，适合快速提取场景。
解释：  
0-9 表示0-9的任何一个数字
. 中扩号的点代表普通字符 点
+ 代表出现一次和多次
综上，代表的是 数字和点的组合[],即只要是数字和点就可以被匹配。稍微严谨一点的话，可以用4位表示：(后者胜在 “格式约束”  )
^([0-9]{1,3}\.){3}[0-9]{1,3}$
解释：  
* ^ 和 $：锚定整个字符串
* [0-9]{1,3}：匹配 1-3 位数字,即：0-999， 如 0 23 128
* 若是加小括号（），即：打包成一个单元
* \. 转义处理，除非放到了中括号中无需转义
* [0-9]{1,3}\.){3} 即：5. 23. 128. 这样的组合为3次。即：5.5.5。  或者5.23.128.
* 最后一段[0-9]{1-3} 无点
组合起来，^([0-9]{1,3}\.){3}[0-9]{1,3}$ 。即严格符合 xxx.xxx.xxx.xxx 的格式。-------格式约束

4、`exec 2>&1` 的用法 
#!/bin/bash
# 脚本开头执行 exec 2>&1，后续所有输出都合并到 stdout
exec 2>&1

# 后续命令的 stdout 和 stderr 都会被重定向到日志文件
ls /tmp > script.log
ls /nonexistent >> script.log  # 错误信息也会追加到 script.log
echo "执行完成" >> script.log
